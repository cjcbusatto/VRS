\documentclass{article}
\usepackage[margin=3pt,landscape]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ stmaryrd }
\usepackage[nopar]{lipsum}%just to generate text for the example
\usepackage{fixltx2e}
\usepackage{textcomp}

% redefinition of \normalsize to use \footnotesize and decrease the values for
% \abovedisplyskip, \belowdisplayskip, and the "short" variants
\makeatletter
\renewcommand\normalsize{%
  \@setfontsize\footnotesize\@viiipt{9.5}%
   \abovedisplayskip 1\p@ \@plus\p@ \@minus\p@
   \belowdisplayskip 1\p@ \@plus\p@ \@minus\p@
   \abovedisplayshortskip \z@ \@plus\p@
   \belowdisplayshortskip \z@ \@plus\p@ \@minus\p@
   \let\@listi\@listI}
\makeatother

\pagestyle{empty}

% multicol parameters
\setlength\premulticols{1pt}
\setlength\postmulticols{1pt}
\setlength\multicolsep{1pt}
\setlength\columnsep{2pt}
\raggedright

% For the source codes
\usepackage{stackengine}
\usepackage{listings}
\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
%  frame=L,
%  xleftmargin=\parindent,
  xleftmargin=0pt,
  language=C,
  showstringspaces=false,
  basicstyle=\tiny\ttfamily,
  tabsize=1,
%  numbersep=8pt,
%  numbers=left,
%  xleftmargin=0.5cm,
  frame=tlbr,
%  framesep=2pt,
  framerule=0pt
}

\lstset{escapechar=@,style=customc}

% For Math Alphabet
\DeclareMathAlphabet{\pazocal}{OMS}{zplm}{m}{n}
\newcommand{\Kb}{\pazocal{K}}
\newcommand{\Ib}{\pazocal{I}}
\newcommand{\Sb}{\pazocal{S}}
\newcommand{\Rb}{\pazocal{R}}
\newcommand{\Ub}{\pazocal{U}}
\newcommand{\Lb}{\pazocal{L}}
\newcommand{\Hb}{\pazocal{H}}
\newcommand{\Bb}{\pazocal{B}}
\newcommand{\Vb}{\pazocal{V}}
\newcommand{\Qb}{\pazocal{Q}}
\newcommand{\Ab}{\pazocal{A}}
\newcommand{\Fb}{\pazocal{F}}
\newcommand{\Db}{\mathfrak{D}}


\begin{document}
\begin{multicols}{4}
\textbf{Propositional Logic - Syntactic Sugar} 
\begin{gather*} 
{\varphi \Leftrightarrow \psi := (\neg \varphi \vee \psi) \wedge (\neg \psi \vee \varphi)} \qquad {\varphi \rightarrow \psi := \neg \varphi \vee \psi} \\
{\varphi \oplus \psi := (\varphi \wedge \neg \psi) \vee (\psi \wedge \neg \varphi) }\qquad {\varphi \barwedge \psi := \neg (\varphi \wedge \psi)} \\
{(\alpha \Rightarrow \beta | \gamma) := ( \neg \alpha \vee \beta) \wedge (\alpha \vee \gamma)} \quad {\varphi \bar{\vee}\psi := \neg (\varphi \vee \psi)}
\end{gather*}
\textbf{Satisfiability, Validity and Equivalence}
\begin{gather*}
\text{SAT}(\varphi) := \neg \text{VALID}(\neg \varphi) \quad \varphi \Leftrightarrow \psi := \text{VALID}(\varphi \leftrightarrow \psi) \\
\text{VALID}(\varphi) := (\varphi \Leftrightarrow 1) \qquad \text{SAT}(\varphi) := \neg(\varphi \Leftrightarrow 0).
\end{gather*}
\textbf{Conjunctive Normal Form:} from truth table, take minterms that are 0. 
Each minterm is built as an OR of the negated variables. E.g., ${(0, 0, 1) \rightarrow (x \vee y \vee \neg z)}$.

\textbf{Distributivity:} ${a \wedge ( b \vee c ) = (a \wedge b) \vee (a \wedge c)}$
${a \vee ( b \wedge c ) = (a \vee b) \wedge (a \vee c)}$

\textbf{Sequent Calculus:}
\begin{enumerate}
\item Prove validity of $\phi$: start with $\{\} \vdash {\phi}$;  $\phi$ is valid iff $\Gamma \cap \Delta \neq \{\}$ for all leaves; else, counterexample: var is true, if $x \in \Gamma$; false otherwise; "don't care", if variable doesn't appear.
\item Prove satisfiability of $\phi$: start with $\{\phi\} \vdash \{\}$; $\phi$ is satisfiable iff $\Gamma \cap \Delta = \{\}$ for at least one leaf. Satisfying interpretation: same as counterexample.
\end{enumerate}
\begin{tabular}{|c|c|c|}
\hline
OPER. & LEFT & RIGHT \\ \hline
NOT & $\frac{\neg \phi,\Gamma \vdash \Delta}{\Gamma \vdash \phi, \Delta}$ & $\frac{\Gamma \vdash \neg \phi, \Delta}{\phi, \Gamma \vdash \Delta}$ \\ \hline
AND & $\frac{\phi \wedge \psi,\Gamma \vdash \Delta}{\phi, \psi,\Gamma \vdash \Delta}$ & $\frac{\Gamma \vdash \phi \wedge \psi, \Delta}{\Gamma \vdash \phi,\Delta \qquad \Gamma \vdash \psi,\Delta}$\\ \hline
OR & $\frac{\phi \vee \psi,\Gamma \vdash \Delta}{\phi,\Gamma \vdash \Delta \qquad \psi,\Gamma \vdash \Delta}$ & $\frac{\Gamma \vdash \phi \vee \psi, \Delta}{\Gamma \vdash \phi, \psi, \Delta}$ \\ \hline
\end{tabular}
\textbf{Resolution Calculus} $\frac{\{\neg x \} \cup C_1 \qquad \{x \} \cup C_2 }{C_1 \cup C_2}$

To prove unsatisfiability of given clauses in CNF: If we reach \{\}, the formula is unsatisfiable. 
E.g., $\{\{a\}, \{\neg a,b\}, \{\neg b\}\}$, we get: $\{a\} + \{ \neg a,b\} \rightarrow \{b\}; \{b\} + \{\neg b\}\rightarrow\{\} $ (unsatisfiable).
To prove validity, prove UNSAT of negated formula.

\textbf{Linear Clause Forms (Computes CNF)} - Bottom up in the syntax tree: convert “operators and variables” into new variable.
E.g., $\neg a \vee b$ becomes $x_1 \leftrightarrow \neg a; x_2 \leftrightarrow x_1 \vee b$. Use rules below to find CNF.
\begin{align*}
x \leftrightarrow \neg y  \Leftrightarrow &(\neg x \vee \neg y) \wedge (x \vee y) \\
x \leftrightarrow y_1 \wedge y_2 \Leftrightarrow &(\neg x \vee y_1) \wedge (\neg x \vee y_2) \wedge\\
&(x \vee \neg y_1 \vee \neg y_2) \\
x \leftrightarrow y_1 \vee y_2 \Leftrightarrow & (\neg x \vee y_1 \vee y_2) \wedge \\
&( x \vee \neg y_1) \wedge (x \vee \neg y_2) \\
x \leftrightarrow y_1 \rightarrow y_2 \Leftrightarrow & (x \vee y_1) \wedge ( x \vee \neg y_1 \vee \neg y_2) \wedge \\
&(\neg x \vee \neg y_1 \vee y_2) \\
x \leftrightarrow (y_1 \leftrightarrow y_2) \Leftrightarrow & (x \vee y_1 \vee y_2) \wedge (x \vee \neg y_1 \vee \neg y_2) \wedge \\
&(\neg x \vee y_1 \vee \neg y_2) \wedge (\neg x \vee \neg y_1 \vee y_2)\\
x \leftrightarrow y_1 \oplus y_2 \Leftrightarrow & (x \vee \neg y_1 \vee y_2) \wedge (x \vee y_1 \vee \neg y_2) \wedge \\ &(\neg x \vee y_1 \vee y_2) \wedge (\neg x \vee \neg y_1 \vee y_2)
\end{align*}

\textbf{Davis Putnam Procedure} - proves SAT; To prove validity: prove unsatisfiability of negated formula.
\textbf{(1)} Compute Linear Clause Form \underline{\textit{(Don't forget to create the last clause $\{x_n\}$)}}
\textbf{(2)}Last variable has to be \underline{1} (true) $\rightarrow$ find implied variables.
\textbf{(3)}For remaining variables: assume values and compute newly implied variables.
\textbf{(4)}If contradiction reached: backtrack.
\setbox0=\hbox{%
\begin{minipage}{0.425\columnwidth}
% Apply
\begin{lstlisting}[mathescape,style=customc] 
Apply($\odot$, Bddnode a, b)
	int m; BddNode h, l;
	if isLeaf(a)&isLeaf(b) then
		return Eval($\odot$,label(a),label(b));
	else
		m=max{label(a),label(b)}
		(a0,a1):=Ops(a,m);
		(b0,b1):=Ops(b,m);
		h:=Apply($\odot$,a1,b1);
		l:=Apply($\odot$,a0,b0);
		return CreateNode(m,h,l)
	end;
end
\end{lstlisting}
\end{minipage}
}
\savestack{\listingA}{\box0}
\setbox0=\hbox{%
%Compose
\begin{minipage}{0.425\columnwidth}
\begin{lstlisting}[mathescape,style={customc}]
Compose$(\text{int x, BddNode }\psi,\alpha)$
	int m; BddNode h, l;
	if x>label($\psi$) then 
		return $\psi$;
	elseif x=label($\psi$) then
		return ITE($\alpha$,high($\psi$),low($\psi$));
	else
		m=max{label$(\psi),\text{label(}\alpha)$}
		($\alpha_0$,$\alpha_1$):=Ops($\alpha$, m);
		($\psi_0$,$\psi_1$):=Ops($\psi$, m);
		h:=Compose(x,$\psi_1$,$\alpha_1$);
		l:=Compose(x,$\psi_0$,$\alpha_0$);
		return CreateNode(m,h,l)
	endif;end
\end{lstlisting}
\end{minipage}
}
\savestack{\listingB}{\box0}
\setbox0=\hbox{%
%ITE
\begin{minipage}{0.425\columnwidth}
\begin{lstlisting}[mathescape,style={customc}]
ITE(BddNode i, j, k)
	int m; BddNode h, l;
	if i = 0 then return k
	elseif i=1 then
		return j
	elseif j=k then
		return k
	else
		m = max{label(i),
						label(j),label(k)}
		($i_0,i_1$):=Ops(i,m);
		($j_0,j_1$):=Ops(j,m);
		($k_0,k_1$):=Ops(k,m);
		l:=ITE($i_0,j_0,k_0$);
		h:=ITE(i1, j1, k1);
		return CreateNode(m,h,l)
	end;end
\end{lstlisting}
\end{minipage}
}
\savestack{\listingC}{\box0}
\setbox0=\hbox{%
%Constrain
\begin{minipage}{0.425\columnwidth}
\begin{lstlisting}[mathescape,style={customc}]
Constrain($\Phi$, $\beta$)
	if $\beta$=0 then
		ret 0
	elseif $\Phi \in \{0,1\} (\beta=1)$
	    ret $\Phi$
	else
		m=max{label$(\beta)\text{,label}(\Phi)$}
    ($\Phi_0,\Phi_1$):=Ops($\Phi$,m);
    ($\beta_0,\beta_1$):=Ops($\beta$,m);
    if $\beta_0$=0
		ret Constrain($\Phi_1,\beta_1$)
	elseif $\beta_1$=0 then
		ret Constrain($\Phi_0,\beta_0$)
	else 
		l:=Constrain($\Phi_0,\beta_0$);
		h:=Constrain($\Phi_1,\beta_1$);
		ret CreateNode(m,h,l)
endif;endif;end
\end{lstlisting}
\end{minipage}
}
\savestack{\listingD}{\box0}

\setbox0=\hbox{%
%Restrict
\begin{minipage}{0.425\columnwidth}
\begin{lstlisting}[mathescape,style={customc}]
Restrict($\Phi,\beta$)
	if $\beta$=0
		return 0
	elseif $\Phi\in \{0,1\}\vee(\beta=1)$
		return $\Phi$
	else
		m=max{label$(\beta)\text{,label}(\Phi)$}
		($\Phi_0,\Phi_1$):=Ops($\Phi$,m);
		($\beta_0,\beta_1$):=Ops($\beta$,m)
	if $\beta_0$=0
		return Restrict($\Phi_1,\beta_1$)
	elseif $\beta_1$=0
		return Restrict($\Phi_0,\beta_0$)
	elseif m=label($\Phi$)
		return CreateNode(m,
			Restrict ($\Phi_1,\beta_1$),
			Restrict ($\Phi_0,\beta_0$))
	else
		return Restrict($\Phi$,
		Apply($\vee,\beta_0,\beta_1$))
	endif;endif;end
\end{lstlisting}
\end{minipage}
}
\savestack{\listingE}{\box0}

\setbox0=\hbox{%
%Constrain
\begin{minipage}{0.425\columnwidth}
\begin{lstlisting}[mathescape,style={customc}]
Ops(v,m)
	x:=label(v);
	if m=degree(x)
		return (low(v),high(v))
	else return(v, v)
end;end
_____________________
Other Diagrams:
TODO ZDD FDD
\end{lstlisting}
\end{minipage}
}
\savestack{\listingF}{\box0}
\begin{tabular}{|l|l|}
\hline
{\listingA} &
{\listingB} \\ \hline
{\listingC} &
{\listingD}\\ \hline
{\listingE} &
{\listingF} \\ \hline
\end{tabular}

\textbf{Simulation}: given ${\Kb_{1}=(\Ib_1,\Sb_1,\Rb_1,\Lb_1)}$ and ${\Kb_{2}=(\Ib_2,\Sb_2,\Rb_2,\Lb_2)}$; ${\sigma \subseteq \Sb_1 \times \Sb_2}$ is a sim. relation between $\Kb_1 \text{ and } \Kb_2$ (${\Kb_1 \preccurlyeq \Kb_2}$) if: \textbf{SIM1-} ${(s_1,s_2) \in \sigma}$ implies ${\Lb_1(s_1)=\Lb_2(s_2)}$; \textbf{SIM2-} for $s_1,s'_{1} \in \Sb_1, s_2 \in \Sb_2$ with ${(s_1,s_2) \in \sigma}$ and ${(s_1,s'_{1}) \in \Rb_1}$, there must be ${s'_2 \in \Rb_2}$ with ${(s'_1,s'_2) \in \sigma}$ ${(s_2,s'_{2}) \in \Rb_2}$; \textbf{SIM3-} for all ${s_1 \in \Ib_1}$, there is a ${s_2 \in \Ib_2}$ with ${(s_1,s_2) \in \sigma}$.

\textbf{Greatest Simulation Relation}
${(s_1,s_2) \in \Hb_{0}\Leftrightarrow \Lb_1(s_1)=\Lb_2(s_2)}$

${(s_1,s_2) \in \Hb_{i+1}\Leftrightarrow}$
\begin{align*}
  \begin{pmatrix}
    (s_1,s_2) \in \Hb_{i} \wedge&\\
    \forall s'_1 \in \Sb_1.\exists s'_2 \in \Sb_2.&\\
    (s_1,s'_1) \in \Rb_1 \rightarrow &(s_2,s'_2) \in \Rb_2 \wedge (s'_1,s'_2) \in \Hb_{i}
  \end{pmatrix}
\end{align*}
$\Hb_*$is the greatest simulation relation if \textbf{SIM3}: ${\Ib_1 \subseteq \{s_1 \in \Sb_1 | \exists s_2 \in \Ib_2 . (s_1, s_2) \in \Hb_* \}}$

\textbf{Bisimulation}:${\sigma \subseteq \Sb_1 \times \Sb_2}$ is a bisim. relation between $\Kb_1 \text{ and } \Kb_2$ (${\Kb_1 \approx \Kb_2}$) if: \textbf{BISIM1-} ${(s_1,s_2) \in \sigma}$ implies ${\Lb_1(s_1)=\Lb_2(s_2)}$; \textbf{BISIM2a-} $s_1,s'_{1} \in \Sb_1, s_2 \in \Sb_2$, ${(s_1,s_2) \in \sigma}$, ${(s_1,s'_{1}) \in \Rb_1}$, imply that there is ${s'_2 \in \Sb_2}$ with ${(s'_1,s'_2) \in \sigma}$ and ${(s_2,s'_{2}) \in \Rb_2}$;\textbf{BISIM2b-} $s_2,s'_{2} \in \Sb_2, s_1 \in \Sb_1$, ${(s_1,s_2) \in \sigma}$, ${(s_2,s'_{2}) \in \Rb_2}$, imply that there is ${s'_1 \in \Sb_1}$ with ${(s'_1,s'_2) \in \sigma}$ and ${(s_1,s'_{1}) \in \Rb_1}$;\textbf{BISIM3a-} for all ${s_1 \in \Ib_1}$, there is a ${s_2 \in \Ib_2}$ with ${(s_1,s_2) \in \sigma}$;\textbf{BISIM3b-} for all ${s_1 \in \Ib_2}$, there is a ${s_2 \in \Ib_2}$ with ${(s_1,s_2) \in \sigma}$.

\textbf{Greatest Bisimulation Relation (Equivalence)}
${(s_1,s_2) \in \Bb_{0}\Leftrightarrow \Lb_1(s_1)=\Lb_2(s_2)}$

${(s_1,s_2) \in \Bb_{i+1}\Leftrightarrow}$
\begin{align*}
  \begin{pmatrix}
    (s_1,s_2) \in \Bb_{i} \wedge\\
    \begin{bmatrix}
    		\forall s'_1 \in \Sb_1.\exists s'_2 \in \Sb_2.\\
   		(s_1,s'_1) \in \Rb_1 \rightarrow (s_2,s'_2) \in \Rb_2 \wedge (s'_1,s'_2) \in \Bb_{i}
    \end{bmatrix}\\
    \begin{bmatrix}
    		\forall s'_2 \in \Sb_2.\exists s'_1 \in \Sb_1.\\
   		(s_2,s'_2) \in \Rb_2 \rightarrow (s_1,s'_1) \in \Rb_1 \wedge (s'_1,s'_2) \in \Bb_{i}
    \end{bmatrix}
  \end{pmatrix}
\end{align*}
$\Bb_*$is the greatest simulation relation if ${\Ib_1 \subseteq \{s_1 \in \Sb_1 | \exists s_2 \in \Ib_2 . (s_1, s_2) \in \Bb_* \}}$ ${\Ib_2 \subseteq \{s_2 \in \Sb_2 | \exists s_1 \in \Ib_1 . (s_1, s_2) \in \Bb_* \}}$

\textbf{Quotient}: given ${\Kb=(\Ib,\Sb,\Rb,\Lb)}$ and the equivalence relation $\sigma \subseteq \Sb \times \Sb$; Quotient structure $\Kb_{/\sigma}=(\widetilde{\Ib},\widetilde{\Sb},\widetilde{\Rb},\widetilde{\Lb})$:
$\widetilde{\Ib}:=\{\{s' \in \Sb | (s,s') \in \sigma \} | s \in \Ib \}$
$\widetilde{\Sb}:=\{\{s' \in \Sb | (s,s') \in \sigma \} | s \in \Sb \}$
$(\widetilde{s}_1,\widetilde{s}_2) \in \Rb :\Leftrightarrow \exists s'_1 \in \widetilde{s}_1. \exists s'_2 \in \widetilde{s}_2.(s'_1,s'_2) \in \Rb$
$\widetilde{\Lb}( \widetilde{s} ):= \Lb(s)$

\textbf{Symbolic Product Computation} - given ${\Kb_1=(\Vb_1,\varphi_{\Ib},\varphi_{\Rb})}$ and ${\Kb_2=(\Vb_2,\psi_{\Ib},\psi_{\Rb})}$, the product is: $\Kb_1 \times \Kb_2 = (\Vb_1 \cup \Vb_2, \varphi_{\Ib} \wedge \psi_{\Ib},\varphi_{\Rb} \wedge \psi_{\Rb} )$
\textbf{Quantif.} ${\exists x.\varphi:=[\varphi]^{1}_{x} \vee [\varphi]^{0}_{x}}\; \clubsuit\; {\forall x.\varphi:=[\varphi]^{1}_{x} \wedge [\varphi]^{0}_{x}}$

\textbf{Predecessor and Successor}
$\diamond := pre^{\Rb}_{\exists}(Q) := \exists x'_1,...,x'_n.\varphi_{\Rb} \wedge [\varphi_{Q}]^{x'_1,...,x'_n}_{x_1,...,x_n}$
$\overleftarrow{\diamond} := suc^{\Rb}_{\exists}(Q) := [\exists x'_1,...,x'_n.\varphi_{\Rb} \wedge \varphi_{Q}]_{x'_1,...,x'_n}^{x_1,...,x_n}$
$\square = pre^{\Rb}_{\forall}(Q) := \forall x'_1,...,x'_n.\varphi_{\Rb} \rightarrow [\varphi_{Q}]^{x'_1,...,x'_n}_{x_1,...,x_n}$
$\overleftarrow{\square} := suc^{\Rb}_{\forall}(Q) := [\forall x'_1,...,x'_n.\varphi_{\Rb} \rightarrow \varphi_{Q}]_{x'_1,...,x'_n}^{x_1,...,x_n}$

\setbox0=\hbox{%
\begin{minipage}{0.425\columnwidth}
% universal predecessor
\begin{lstlisting}[mathescape,style=customc] 
$pre_{\forall}^{\Rb}(Q=\{S_1,...,S_n\})$
for each node n in $\Kb$:
	if(n points to a node that is not in Q)
		n $\notin pre_{\forall}^{\Rb}(Q)$
	else
		n $\in pre_{\forall}^{\Rb}(Q)$
\end{lstlisting}
\end{minipage}
}
\savestack{\listingG}{\box0}
\setbox0=\hbox{%
% universal successor
\begin{minipage}{0.425\columnwidth}
\begin{lstlisting}[mathescape,style={customc}]
$suc_{\forall}^{\Rb}(Q=\{S_1,...,S_n\})$
for each node n in $\Kb$:
	if(n is pointed by a node that is not in Q)
		n $\not\in suc_{\forall}^{\Rb}(Q)$
	else
		n $\in suc_{\forall}^{\Rb}(Q)$
\end{lstlisting}
\end{minipage}
}
\savestack{\listingH}{\box0}

\begin{tabular}{|l|l|}
\hline
{\listingG} &
{\listingH} \\ \hline
\end{tabular}

\textbf{Tarski-Knaster Theorem}: $\mu := \text{starts} \; \bot \rightarrowtriangle \text{least fixpoint} \;\spadesuit \; \nu :=\text{starts} \;\top \rightarrowtriangle \text{greatest fixpoint}$

\textbf{Local Model Checking}

\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{2}{|l|}{$\frac{s \vdash_{\Phi} \varphi \wedge \psi}{\{s \vdash_{\Phi} \varphi \} \quad \{s \vdash_{\Phi} \psi\}} \wedge$} & \multicolumn{2}{|l|}{$\frac{s \vdash_{\Phi} \varphi \vee \psi}{\{s \vdash_{\Phi} \varphi \} \quad \{s \vdash_{\Phi} \psi\}} \vee $}\\ \hline
\multicolumn{2}{|l|}{$\frac{s \vdash_{\Phi} \square \varphi}{\{s_1 \vdash_{\Phi} \varphi\} \dots \{s_n \vdash_{\Phi} \varphi\}} \wedge$}&\multicolumn{2}{|l|}{$\frac{s \vdash_{\Phi} \diamond \varphi}{\{s_1 \vdash_{\Phi} \varphi\} \dots \{s_n \vdash_{\Phi} \varphi\}} \vee$} \\
 \hline
\multicolumn{2}{|l|}{$\frac{s \vdash_{\Phi} \overleftarrow{\square} \varphi}{\{s'_1 \vdash_{\Phi} \varphi \}\dots \{ s'_n \vdash_{\Phi} \varphi\}} \wedge$} &\multicolumn{2}{|l|}{$\frac{s \vdash_{\Phi} \overleftarrow{\diamond} \varphi}{\{s'_1 \vdash_{\Phi} \varphi \}\dots \{ s'_n \vdash_{\Phi} \varphi\}} \vee$} \\
 \hline
$\frac{s \vdash_{\Phi} \mu x.\varphi}{s \vdash_{\Phi} \varphi}$ &$\frac{s \vdash_{\Phi} \nu x.\varphi}{s \vdash_{\Phi} \varphi}$&$\frac{s \vdash_{\Phi} x}{s \vdash_{\Phi} \Db_{\Phi}(x)}$&$\frac{\Db_{\Phi}\text{\tiny (replace w.}}{\text{\tiny initial form.)}}$\\
 \hline
\multicolumn{4}{|l|}{$\{s_1 \dots s_n \}=suc^{\Rb}_{\exists}({s})$ and $\{s'_1 \dots s'_n \}=pre^{\Rb}_{\exists}({s})$}\\ \hline 
\end{tabular}
\textbf{Approximations and Ranks}
\begin{tabular}{|l|l|}
\hline
If (s,$\mu x.\varphi$) repeats$\rightarrow$return 1&$apx_0(\mu x.\varphi):=0$\\ \hline
If (s,$\nu x.\varphi$) repeats$\rightarrow$return 0& $apx_0(\nu x.\varphi):=1$\\ \hline
\multicolumn{2}{|l|}{$apx_{n+1}(\mu x.\varphi):=[\varphi]_{x}^{apx{n}(\mu x.\varphi)}$}\\ \hline
\multicolumn{2}{|l|}{$apx_{n+1}(\nu x.\varphi):=[\varphi]_{x}^{apx{n}(\nu x.\varphi)}$}\\ \hline
\end{tabular}
\textbf{Automata types:} G$\rightarrow$Safety; F$\rightarrow$Liveness; FG$\rightarrow$Persistence/Co-Buchi; GF$\rightarrow$Fairness/Buchi.

\textbf{\underline{Automaton Determinization}}\\
\textbf{NDet\textsubscript{G}\textrightarrow Det\textsubscript{G}:} 
1.Remove all states/edges that do not satisfy acceptance condition;
2.Use Subset construction (Rabin-Scott);
3.Acceptance condition will be the states where \{\} is never reached. \\
\textbf{\{NDet\textsubscript{F}(partial) or NDet\textsubscript{prefix}\}\textrightarrow Det\textsubscript{FG}:} 
Breakpoint Construction. \\
\textbf{NDet\textsubscript{F} (total)\textrightarrow Det\textsubscript{F}:}
Subset Construction. \\
\textbf{NDet\textsubscript{FG}\textrightarrow Det\textsubscript{FG}:}
Breakpoint Construction.\\
\textbf{NDet\textsubscript{GF}\textrightarrow \{Det\textsubscript{Rabin} or Det\textsubscript{Streett}\}:}
Safra Algorithm.
%\lipsum  %generate random text so we better see the cheat sheet

%% TODO: Organize latter from here on the order of the things. Follow the rest of the content of the first side of the sheet

\textbf{Automata Formulas}

\underline{Complement}
\begin{align*}
\neg \Ab_{\forall}(Q,\Ib,\Rb,\Fb)=\Ab_{\exists}(Q,\Ib,\Rb,\neg \Fb) \\
\neg \Ab_{\exists}(Q,\Ib,\Rb,\Fb)=\Ab_{\forall}(Q,\Ib,\Rb,\neg \Fb)
\end{align*}
\underline{Conjunction}
\begin{align*}
(\Ab_{\exists}(Q_1,\Ib_1,\Rb_1,\Fb_1)\wedge \Ab_{\exists}(Q_2,\Ib_2,\Rb_2,\Fb_2)&)=\\
\Ab_{\exists}(Q_1 \cup Q_2,\Ib_1 \wedge \Ib_2,\Rb_1 \wedge \Rb_2,\Fb_1 \wedge \Fb_2)&
\end{align*}

\underline{Disjunction}
\begin{align*}
(\Ab_{\exists}(Q_1,\Ib_1,\Rb_1,\Fb_1)\vee \Ab_{\exists}(Q_2,\Ib_2,\Rb_2,\Fb_2)&)=\\
\Ab_{\exists} \begin{pmatrix}
Q_1 \cup Q_2 \cup \{q\},\\
(\neg q \wedge \Ib_1) \vee (q \wedge \Ib_2), \\
(\neg q \wedge \Rb_1 \wedge \neg q') \vee ( q \wedge \Rb_2 \wedge q'), \\
(\neg q \wedge \Fb_1) \vee (q \wedge \Fb_2)
  \end{pmatrix}
\end{align*}
\textit{If both automata are totally defined,}
\begin{align*}
(\Ab_{\exists}(Q_1,\Ib_1,\Rb_1,\Fb_1)\vee \Ab_{\exists}(Q_2,\Ib_2,\Rb_2,\Fb_2)&)=\\
\Ab_{\exists}(Q_1 \cup Q_2,\Ib_1 \wedge \Ib_2,\Rb_1 \wedge \Rb_2,\Fb_1 \vee \Fb_2)
\end{align*}
\underline{Eliminate Nesting} - Acceptance condition \textbf{must} be an automata of the same type
\begin{align*}
\Ab_{\exists}(Q^1,\Ib_1^1,\Rb_1^1,\Ab_{\exists}(Q^2,\Ib_1^2,\Rb_1^2,\Fb_1))\\
= \Ab_{\exists}(Q^1 \cup Q^2,\Ib_1^1 \wedge \Ib_1^2,\Rb_1^1 \wedge \Rb_1^2,\Fb_1))
\end{align*}
\underline{Boolean Operations of G}
\begin{align*}
(1)\neg G \varphi = F \neg \varphi\qquad \qquad  (2)G \varphi &\wedge G \psi = G[\varphi \wedge \psi]\\
(3) G \varphi \vee G \psi = \Ab_{\exists}(\{p,q\},p \wedge q,&\qquad\qquad\\
[p' \leftrightarrow p \wedge \varphi] \wedge &[q' \leftrightarrow q \wedge \psi],G[p \vee q])
\end{align*}
\underline{Boolean Operations of F}
\begin{align*}
(1)\neg F \varphi = G \neg \varphi\qquad \qquad\quad\;(2)F \varphi &\vee F \psi = F[\varphi \vee \psi]\\
(3) F \varphi \wedge F \psi = \Ab_{\exists}(\{p,q\}, \neg p \wedge \neg q,&\qquad\qquad\\
[p' \leftrightarrow p \vee \varphi] \wedge [q' \leftrightarrow & q \vee \psi],F[p \wedge q])
\end{align*}
\underline{Boolean Operations of FG}
\begin{align*}
(1)\neg FG \varphi = GF \neg \varphi\qquad(2)FG \varphi \wedge FG \psi = FG[\varphi \wedge \psi]\\
(3) FG \varphi \vee FG \psi = \Ab_{\exists}(\{q\}, \neg q, q' \leftrightarrow (q \Rightarrow \psi | \neg \varphi),\\
FG[\neg q \vee \psi])
\end{align*}
\underline{Boolean Operations of FG}
\begin{align*}
(1)\neg GF \varphi = FG \neg \varphi \qquad(2)GF \varphi \vee GF \psi = GF[\varphi \vee \psi]\\
(3) GF \varphi \wedge GF \psi = \Ab_{\exists}&(\{q\}, \neg q, q' \leftrightarrow (q \Rightarrow \neg \psi | \varphi),\\
GF[q \wedge \psi])
\end{align*}
\textbf{Transformation of Acceptance Conditions}
\underline{Reduction of G}
\begin{align*}
G\varphi &= \Ab_{\exists}(\{q\},q,\varphi \wedge q \wedge q',F q))\\
G\varphi &= \Ab_{\exists}(\{q\},q, q' \leftrightarrow q \wedge \varphi,FG q) \\
G\varphi &= \Ab_{\exists}(\{q\},q, q' \leftrightarrow q \wedge \varphi,GF q) 
\end{align*}
\underline{Reduction of F}
\begin{align*}
F\varphi &\text{ can \textbf{\underline{not}} be expressed by } NDet_G\\
F\varphi &= \Ab_{\exists}(\{q\},\neg q, q' \leftrightarrow q \vee \varphi,FG q) \\
F\varphi &= \Ab_{\exists}(\{q\},\neg q, q' \leftrightarrow q \vee \varphi,GF q) 
\end{align*}
\underline{Reduction of FG}
\begin{align*}
FG\varphi &\text{ can \textbf{\underline{not}} be expressed by } NDet_G\\
FG\varphi &= \Ab_{\exists}(\{q\},\neg q, q \rightarrow \varphi \wedge q',F q) \\
FG\varphi &= \Ab_{\exists} \begin{pmatrix}
\{p,q\},\qquad \neg p \wedge \neg q,\\
	\begin{bmatrix}
(p \rightarrow p') \wedge (p' \rightarrow p \vee \neg q) \wedge \\
(q' \leftrightarrow (p \wedge \neg q \vee \neg \varphi) \vee (p \wedge q))
    \end{bmatrix},\\
    G \neg q \wedge F p
\end{pmatrix}\\
FG\varphi &= \Ab_{\exists} \begin{pmatrix}
\{p,q\},\qquad \neg p \wedge \neg q,\\
	\begin{bmatrix}
(p \rightarrow p') \wedge (p' \rightarrow p \vee \neg q) \wedge \\
(q' \leftrightarrow (p \wedge \neg q \vee \neg \varphi) \vee (p \wedge q))
    \end{bmatrix},\\
    GF[p \wedge \neg q]
\end{pmatrix}
\end{align*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%% Other side of the previous sheet! %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Defining first the boxes content
\setbox0=\hbox{%
\begin{minipage}{0.425\columnwidth}
$EX\varphi = \diamondsuit (\Phi_{inf} \wedge \varphi)$ \\
$EG\varphi = \nu x.\varphi \wedge \diamondsuit x $ \\
$EF\varphi = \mu x.\Phi_{inf} \wedge \varphi \vee \diamondsuit x  $ \\
$E[ \varphi \underline{U} \psi] = \mu x.(\Phi_{inf} \wedge \psi) \vee \varphi \wedge \diamondsuit x $ \\
$E[ \varphi U \psi] = \nu x.(\Phi_{inf} \wedge \psi) \vee \varphi \wedge \diamondsuit x $ \\
$E[ \varphi \underline{B} \psi] = \mu x.\neg\psi \wedge (\Phi_{inf} \wedge \varphi \vee \diamondsuit x) $ \\
$E[ \varphi B \psi] = \nu x.\neg\psi \wedge (\Phi_{inf} \wedge \varphi \vee \diamondsuit x) $ \\
\end{minipage}
}
\savestack{\listingFE}{\box0}

\setbox0=\hbox{%
\begin{minipage}{0.425\columnwidth}
TODO
\end{minipage}
}
\savestack{\listingFF}{\box0}

%Organizing the boxes
\textbf{CTL to $\mu -Calculus (\Phi _{inf} = \nu y.\diamondsuit y$)}
\begin{tabular}{|l|l|}
\hline
{\listingFE} &
{\listingFF} \\
\hline
\end{tabular}

\end{multicols}
\end{document}